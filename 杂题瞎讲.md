# Problem A

http://zhengruioi.com/contest/745/problem/1670

长度为$n$初始全0的序列，两人轮流在上面选择连续的一段长度不超过$k$的$0$变成一段$1$，如无法选择则输，问先手是否必胜

$1\leq k\leq n\leq 1e9$

$hint:$这是problem A

<div STYLE="page-break-after: always;"></div>

如果先手能从中间选择一段把序列分成两段相等长度的，则只需要跟对手镜像走一定可以获胜；$k\geq 2$一定可以，否则只有奇数可以

<div STYLE="page-break-after: always;"></div>

# Problem B

http://zhengruioi.com/contest/716/problem/1593

给定两个字符串$s,t$，取$s$的一个前缀接上$t$的一个后缀构成新字符串(可以为空串)，求有多少种不同的新字符串

$1\leq |S|,|T|\leq 1e7$

<div STYLE="page-break-after: always;"></div>

假设已经选定$s[1,i]$作为前缀，那么$t[j,n]$以前不能有$s[1,i]$的后缀，而只要限定$t[j-1]!=s[i]$就一定满足条件，否则这一组贡献一定被计算过

<div STYLE="page-break-after: always;"></div>

# Problem C

http://zhengruioi.com/contest/719/problem/1612

给定一字符串$s$，求最多可以选出多少子串(连续)使得他们彼此不是后缀

$|S|\leq 1e6$

<div STYLE="page-break-after: always;"></div>

以$i$为最后一个点最多只能贡献1，所以我们只要看它能不能贡献，考虑如果$j<i$且以两者为终点无论怎么选都会冲突，一定有$s[1,j]$是$s[1,i]$的后缀，而且为了后面考虑我们舍弃$j$保留$i$；否则一定存在一种起点的选法使两串不冲突；所以我们KMP的时候每次把$nxt[i]$的位置标成$false$，最后统计没有被标的位置的个数就是答案

<div STYLE="page-break-after: always;"></div>

# Problem D

http://zhengruioi.com/contest/754/problem/1674

给定一字符串$s$，求有多少长度为$6$的子序列满足相等/不相等关系形如$114514$

$|s|\leq 5e5$

<div STYLE="page-break-after: always;"></div>

枚举$5$的位置，我们需要知道前缀$114$的数量和后缀$14$的数量，通过dp

$dp0[i][x]$表示$[1,i]$中$x$的个数，$dp0[i][x]=dp0[i-1][x]+[a[i]==x]$

$dp1[i][x]$表示$[1,i]$中$xx$的个数，$dp1[i][x]=dp1[i-1][x]+[a[i]==x]\times dp0[i-1][x]$

$dp2[i][x][y]$表示$[1,i]$中$xxy$的个数，$dp2[i][x][y]=dp2[i-1][x][y]+[a[i]==y]\times dp1[i-1][x]$

$dp3[i][x][y]$表示$[i,n]$中$xy$的个数，$dp3[i][x][y]=dp3[i+1][x][y]+[a[i]==x]\times(dp0[n][y]-dp0[i][y])$

$ans=\sum\limits_{x!=a[i]}\sum\limits_{y!=a[i]~\&~x!=y}dp2[i-1][x][y]\times dp3[i+1][x][y]$

卡了空间，不能开这么多数组，先把$i==1$时$dp3[x][y]$算出来，这样向后推的时候四个式子都能动态维护省掉第一维

<div STYLE="page-break-after: always;"></div>

# Problem E

http://zhengruioi.com/contest/730/problem/1642

给定一个初始的01串，一次操作把原来所有相邻的前0后1进行交换构成新串，求$t$次操作后的字符串串，以及每一次操作后的逆序对数量

<div STYLE="page-break-after: always;"></div>

对每一个字符1求其在第$i$次操作中能否向前交换，能1不能0；

如果当前字符的前一位也是1，那么状态就会比前一位整体慢一步，并且第一步也是0；否则如果和上一个1之间隔了$k$个0，可以先认为两个1是相邻的计算移动状态，每次当前的1被卡位了就无中生有一个0让它能继续移动，所以就将状态前$k$个0变成1；

维护状态可以通过deque维护移动状态中所有$0$的位置并打全局$tag$；

第$i$位字符1的移动状态中有$j$个0就意味着阻止了$t$次移动中的$j$次，所以这一位的1最终的位置在$i-t+j$；

每一个1每移动一次就会增加一个逆序对个数，所以操作一次的逆序对变化量就是当前操作时间上所有字符1的移动数量，而某一位字符的移动状态中的一个0变成1，会使其之后的所有字符1的移动状态上慢1,2,3...位也从0变成1；所以记录当前操作位是否变化是移动数量的差分值，求和之后就是逆序对的变化量了

<div STYLE="page-break-after: always;"></div>

# Problem F

http://zhengruioi.com/contest/684/problem/1533

给出一字符串$s$，求形如$AA^*A$的子串(连续)的数量，其中$A^*$是$A$的倒序

$hint:manacher$

<div STYLE="page-break-after: always;"></div>

首先可以通过manacher O(n)算出以每个点为中心的最长回文串$AA^*$半径$len[i]$

考虑枚举所求字串前1/3位置$i$，则能对该点产生1贡献的后1/3位置$x$满足$x\in[i+1,i+len[i]] \&\& x-len[x]<i$，这样倒着做的时候后一个条件单调减可以保证永远满足 则前一个条件用树状数组表示x位置是否可以为当前及更往前的位置贡献可以维护

<div STYLE="page-break-after: always;"></div>

# Problem G

http://zhengruioi.com/contest/696/problem/1491

给定一串01串，每次操作可以将连续的 长度为$k$的颜色相同串颜色反转；求经过若干次操作后a能否变成b

<div STYLE="page-break-after: always;"></div>

在给定某些操作 求字符串a是否可以转换成b时 当操作可逆时 一种思路是尝试把a,b向另外一个状态(比如最小字典序)转移

本题中注意到$k\times '0'+'1'$可以转移到$'1'+k\times '0'$，所以我们求最大字典序时可以把$u$个$k\times '0'$扔到后面去；同理把$v$个$k\times '1'$扔到前面去，记录下a,b的u,v个数，以及卡在中间无法转移的字符串，比较即可

<div STYLE="page-break-after: always;"></div>

# Problem H

